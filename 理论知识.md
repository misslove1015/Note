# 理论知识
**平时自己的一些总结，主要是看博客学习的，再加上自己的一点总结，排名无先后。**
*****

### 1. MVC、MVP、MVVM
* **MVC**  
  M：Model、V：View、C：Controller，在使用中，C作为M和V的连接，负责M和V的同步，一旦M改变，V也应该及时更新。   
  优点：耦合性低，重用度高，可维护性高，开发效率高   
  缺点：没有区分业务逻辑和业务展示，对单元测试不友好，同时controller会变得越来越大，需要拆分来解决
  
* **MVP**  
  M：Model、V：View、P：Presenter，MVP由MVC发展而来，在MVP中P拆分了C的业务逻辑，M和V的功能不变，C现在只负责布局。  
  优点：模块清晰职责分明、友好的单元测试  
  缺点：分层导致代码可能有点绕，需要写更多的代码

* **MVVM**  
  M：Model、V：View、VM：ViewModel，MVVM采用数据绑定的方式来进行数据更新， 可以看做是MVP的绑定进化体   
  优点：相比MVP减少了大量代码，同时优化了代码逻辑   
  缺点：由于采用了数据绑定，使得bug难以追踪，同时学习成本相对较高
  
### 2. NSString用copy和strong有什么区别
  当源字符串是NSString的时候，由于NSString是不可变的，不管是strong还是copy，都是指向源对象，strong只是单纯增加对象的引用计数，copy则对源对象执行了一次浅拷贝。

  当源字符串是NSMutableString时，strong依旧只是增加了对象的引用计数，还是指向源对象，所以当源对象修改时，strong修饰的对象也会发生变化。copy则是对源对象做了一次深拷贝，产生了一个新对象，所以当源对象发生变化时，copy修饰的对象不会变化。

  当我们声明一个NSString时，一般我们不希望它发生变化，所以建议使用copy。

### 3. 栈和堆

* **栈（stack）**  
  由系统自动分配，一般存放函数参数值、局部变量的值等。由编译器自动创建和释放。操作方式类似数据结构的栈，即后进先出，先进后出的原则。

* **堆（heap）**   
  一般由开发者申请并指明大小，最终也由开发者释放，如果开发者不释放，程序结束后可能由OS回收。对于堆区的管理是采用链表式管理的，操作系统有一个记录空闲内存地址的链表，当接收到程序分配内存的申请时，操作系统就会遍历该链表，遍历到一个记录的内存地址大于申请内存的链表节点，并将该节点从该链表中删除，然后将该节点记录的内存地址分配给程序。

* **全局区/静态区（static）**   
  全局变量和静态变量的存储是放在一块的，初始化的  
全局变量和静态变量在一块区域未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。  

* **文字常量区**  
  常量字符串就是放在这里的，程序结束后由系统释放
  
* **程序代码区**  
  存放函数体的二进制代码
    
### 4. block
  **block：带有自动变量的匿名函数。本质上是一个存储代码段OC对象。**

  block有三种类型     
   
* **_NSConcreteGlobalBlock**  
  全局的静态block，不会访问任何外部变量，不会涉及到任何拷贝。当一个block没有访问任何外部变量时，就是_NSConcreteGlobalBlock。  
* **_NSConcreteStackBlock**  
  保存在栈中的block，当一个block访问了外部变量时会存储在栈区，这时的block在调用后就会被释放。    
* **_NSConcreteMallocBlock**  
  保存在堆中的block，当引用计数为0时被销毁。该类型的block都是由_NSConcreteStackBlock类型的block从栈中复制到堆中形成的。

**block为什么用copy修饰**  
  默认情况下，block都是存在栈中的，随时会被回收，所以需要copy一份到堆里，在堆里的block是随着对象的销毁而结束的，只要对象不销毁，就可以一直调用在堆里的block。

**block中变量的修改**  
  block中可以直接修改全局变量和静态变量。对于局部变量，block默认是将其复制一份到其数据结构中来实现访问的，而通过block进行闭包的变量是const的，所以block不能直接修改局部变量的值。要想改变局部变量的值需要加\_\_block,对于加了__block的变量，block是复制其地址来实现访问的,所以可以改变。

**block的循环引用**  
  当self持有一个block的时候，block中又调用了self的方法，就会出现循环引用。
解决方法是将self定义为\_\_weak typeof(self) weakSelf = self,使强用变为弱引用。

**为什么系统block中很多可以直接用self**  
  以UIView动画block为例，这是一个类方法，当前控制器不可能强引用一个类对象，循环也就无法形成。另外AFNetworking的block也不会造成循环引用，AFURLConnectionOperation
 里的一个请求结束之后，setCompleteBlock会把block设置为nil，来打破循环引用。只要记得循序引用产生的必要条件：我引用你，而你又引用我。

### 5. 进程和线程

* **进程**  
  正在运行的一个应用程序，负责程序的内存分配。每一个进程之间是独立的，且运行在其专用且受保护的内容空间内。

* **线程**   
  进程中的一个独立的执行单元，线程是进程的组成部分。一个进程可以有多个线程，但至少有一个线程（主线程），一个线程只能属于一个进程。在进程初始化时，主线程也就被创建了，主线程是系统自动创建的，分线程需要手动创建。一个线程的任务执行是串行的，同一个时间内，一个线程只能执行一个任务。

### 6. 成员变量、实例变量、属性、全局变量

* **成员变量**  
  写@interface和@implementatio大括号里的变量，成员变量属于类内部。在.h里的成员变量，子类可以继承和访问，其他类无法访问；在.m中的成员变量，无法被继承，也无法被访问。

* **实例变量**  
  实例变量本质上也是成员变量，不过当一个变量的类型是一个类的时候称它为实例变量。除去基本数据类型的成员变量，其他类型的成员变量都叫做实例变量。

* **属性**  
  属性用@property来声明，会自动生成setter和getter方法，写在.h的属性其他类可以访问，写在.m的属性只有本类可以访问。声明属性时，会自动生成一个同名的加下划线的实例变量。属性本质上是实例变量+set方法+get方法。

* **全局变量**  
  全局变量一般写在#import下面，一个项目不能存在两个名字一样的全局变量，其他类想要访问不在本类的全局变量，需加extern关键字。extern作用：先在本文件查找全局变量，如果没有找到，去其他文件查找。  
静态全局变量：如果在全局变量前加了static，那么这个全局变量只能在本文件使用，其他类无法访问，加extern也不行。

### 7. static、const、extern

* **static**
  * 修饰局部变量时，只会初始化一次，并延长局部变量的生命周期，到程序结束时才会销毁。
  * 修饰全局变量时，改变全局变量的作用域，使其只能在本文件访问。也避免了重复定义全局变量导致报错，在本文件定义了static的全局变量，其他文件依然可以定义重名的全局变量。
  
* **const**   
  不可变的，const仅仅用来修饰其右边的变量，被const修饰的变量是只读的。

* **extern**  
  用来获取全局变量的值

### 8. static const 和 #define

* 相同点：都不能被修改，一处修改，其他都改。 

* 不同点：static const修饰的变量只有一份内存，#define只是简单的替换。#define可以定义函数，static const不可以。

### 9. @synthesize和@dynamic
* **@synthesize**  
  如果没有手动实现setter和getter方法，让编译器自动生成setter和getter方法。
* **@dynamic**  
  告诉编译器属性的setter和getter方法由用户自己实现，不自动生成。   

@synthesize和@dynamic都没写，默认是@synthesize。

### 10. 属性的关键字
ARC下基本数据类型默认关键字为：atomic、assign、readwrite  
普通OC对象默认关键字：atomic、strong、readwrite

* **atomic**  
  默认关键字，对于atomic的属性，对系统生成的setter和getter方法，系统会保证set和get的完整性，不受其他线程的影响。比如线程A的getter方法运行到一半，线程 B 调用了 setter，那么线程 A 的 getter 还是能得到一个完好无损的对象，相当于在函数头尾加了锁。如果是自己写的setter和getter方法，则atmoic没有作用。但atomic并非绝对的线程安全，它只会增加正确的几率，如果一个线程在频繁的get一个变量的值，而另一个线程同时在set这个变量，还是会读取到不同的值，atomic只会保证一个setter或getter方法的完整性。另外由于只能保证setter和getter方法的完整性，比如对象是一个NSMutableArray时，NSMutableArray还可以addObject，这时atomic也不能保证绝对的线程安全。

* **nonatomic**  
  iOS中应该使用的属性关键字。因为在iOS中使用同步锁的开销比较大，使用nonatomic可以提高效率；atomic并不会保证绝对的线程安全，如果要保证绝对的线程安全还需要其他措施；在iOS中一般都是主线程在操作，如果没有多线程的通讯，应该用nonatmoic。既然在iOS中都是nonatmoic，为什么苹果默认是atmoic，因为在Mac OS中默认是atmoic，Mac OS性能不是瓶颈，iOS用nonatmoic主要是出游性能考虑。

* **assign**  
  用于基本数据类型、结构体、枚举等，不更改引用计数。如果用来修饰对象，对象被释放时，指针地址依然存在，不会自动置nil，会成为野指针。之所以可以修饰基本数据类型，因为基本数据类型一般分配在栈上，有系统来管理，不会造成野指针。

* **weak**  
  用于代理、UI控件等，weak不会导致引用计数的增加，只是单纯的指向某个地址，是一种弱应用，当对象被释放时，指针会自动置nil。

* **strong**  
  用于OC对象，强引用，只要有一个strong的指针指向对象，那么对象就不会释放。strong等同于MRC下的retain，会导致对象引用计数+1。

* **retain**  
  用于OC对象，强引用，retain的属性set方法会先判断两个值是否相同，不同的话先release原先的值，再retain新值，会导致引用计数+1。ARC后被strong替换，和strong的区别在于，修饰block时，strong相当于copy，会把block从栈copy到堆，而retain相当于assign，block仍在栈中。

* **copy**  
  用于NSString、block等，copy会在堆中复制一个一样的对象，旧的值release掉，指向新的复制的对象。与retain的区别在于，copy会生成一个新的对象。

* **readwrite**  
  可读写的，修饰的变量会有setter和getter方法

* **readonly**  
  只读的，只会生成getter方法,当用点操作来为属性赋值时，将会报错。

### 11. 为什么IBOutlet连线的控件使用weak
* **IBOutlet**  
这时的引用关系为UIViewController -> UIView -> subView -> 控件，这几个都是强引用，此时控件的引用计数为1，持有者是subView，所以就没必要再强引用一次了，只要一个weak指针指向它就可以了。   
* **自己申明的控件**  
如果是自己声明的UI控件那么用strong和weak都是可以的，如果是weak那么和IBOutlet连线是一样的，持有控件的是subView。如果是strong，那么持有该控件的是UIViewController，可以看做是UIViewController将某个控件放到了其他view上，当放到其他view上时，subView会copy一次，导致控件的引用计数再次+1，最后UIViewController手里有一份，subview手里也有一份。  
但使用strong一般情况下也不会导致控件无法被释放，虽然strong修饰的控件会让控件引用计数+2，但控制器释放时，UIViewController、UIView、subView都释放了，UIViewController释放导致控件引用计数-1，subView释放导致控件引用计数-1，最后控件应用计数仍为0，可以正常的被释放。

### 12. 同步和异步、串行和并行

同步和异步是任务的执行方式，串行和并行是队列的类型。队列只负责任务的调度，不负责任务的执行，任务的执行在线程中。

* 同步：不会开启新的线程，任务按顺序执行。

* 异步：会开启新的线程，任务可以并发的执行。

* 串行队列：任务按照顺序执行，一个任务执行完毕，再执行下一个任务。

* 并行队列：可以让多个任务同时执行，会自动开启多个线程同时来执行任务

同步和异步、串行和并行两两组合就成了串行队列同步执行、串行队列异步执行、并行队列同步执行、并行队列异步执行。

*  串行队列同步执行：按照顺序一个一个执行，不会新建线程。
  
*  串行队列异步执行：虽然队列存放的是异步任务，但串行队列的方式是前一个任务执行完毕，下一个任务才会开始执行，所以还是按照顺序一个一个执行。该操作需要一个子线程，会新建线程，线程的创建和回收不需要开发者参与。
  
*  并行队列同步执行：虽然并行队列可以不用等前面的任务执行完毕，就可以调度下一个任务，但由于是同步执行不会开启新的线程，所以任务还是按照顺序一个一个执行。不会新建线程。
  
*  并行队列异步执行：这个可以实现任务的并发，任务无序执行。会新建多个线程。

另外还有主队列和全局队列，主队列是一个特殊的串行队列，全局队列是一个特殊的并行队列，主队列和全局队列都不用创建，可以直接获取。

* 主队列同步执行：死锁。当一个同步任务被添加到主队列，同步任务会被放到主队列的最后面，想要执行这个同步任务，必须等主线程把同步任务前面的任务执行完毕，而这又是一个同步任务，不执行完这个同步任务主线程不要想去执行其他任何任务，所以就出现了主线程在等待同步任务执行完毕，同步任务在等待主队列里排在它前面的任务执行完毕，互相等待的状态。 
 
* 主队列异步执行：虽然是异步任务，但在主队列里并不会开启新的线程，只是降低异步任务的优先级，让CPU空闲的时候再去调用。

* 全局队列同步执行：不会新建线程，任务按照顺序执行。

* 全局队列异步执行：会新建多个线程，任务无序执行。

### 13. #include、#import和@class

* **\#include**
  C/C++导入头文件的关键字，使用#include要注意重复导入的问题，如果ClassA和ClassB都导入了ClassC，在ClassD同时导入ClassA和ClassB的话，将会提示重复导入ClassC的错误。

* **\#import**
  OC导入头文件的关键字，大部分功能和#include一样，但它解决了重复导入的问题，如果我们重复导入了文件，#import会自动处理，确保文件只会被导入一次，相当于#include和#pragma once。这也是它和#include的区别。
  
* **@class**
  \#import导入类会包含这个类.h里所有的变量和方法，而@class只是告诉有这个类的存在。@class一般出现在.h里导入其他类时，因为这时还用不到导入类的变量和方法，如果在.m里需要用到导入类的变量和方法还是需要#import。

### 14. 代理、block和通知

* **代理**  
一对一，需要声明协议，并实现协议方法。优点是较为清晰的语法定义，有条理性；缺点是书写麻烦，需要声明协议并实现等等。在方法较多时应选择delegate。

* **block**  
一对一，书写简单，优点是代码紧凑，逻辑不分散，可以方便的访问上下文数据；缺点是使用时要注意循环引用的问题。

* **通知**  
一对多，主要用于跨层或跨功能的通信。优点是书写简单，可以一对多；缺点是会导致bug难以追踪，难以维护，释放注册对象时，需要取消注册。

### 15. Category和Extension

* **Category**  
  类别，使用类别可以方便的给现有类增加方法，类别的好处是不改动现有类即可以增加方法，主要用于原生类和第三方库。类别不能添加属性，如果要添加需要使用runtime来添加。
  
* **Extension**
  类扩展，可以看作是特殊的类别，也叫做匿名分类。类扩展可以添加方法和变量，但添加的方法和变量都是私有的，同时添加的方法必须要实现。类扩展必须有一个类的源码才能添加，对于系统的一些类无法添加类扩展。
  
### 16. 类方法和实例方法

* **类方法**
  * 类方法是属于类对象的
  * 类方法只能通过类对象来调用
  * 类方法中不能调用实例方法，但可以通过创建对象来访问实例方法
  * 类方法中不能访问实例变量
  * 类方法中的self是类对象

* **实例方法**
  * 实例方法是属于实例对象的
  * 实例方法只能通过实例对象来调用
  * 实例对象中可以方法实例变量
  * 实例方法中可以调用类方法
  * 实例方法中的self是实例对象

### 17. **KVC和KVO**

* **KVC**  
  KeyValueCoding，键值编码，一个非正式的protocol，提供一种机制来间接的访问对象属性，而不是通过setter、getter方法。使用KVC可以访问一个类的私有变量。使用KVC要注意key的值，因为key的值是个字符串，书写错误编译器不会提示。
  
* **KVO**  
  KeyValueObserve，键值观察，基于KVC，属于观察者模式。KVO使用非常简单，先添加观察者，然后实现监听方法，在被观察者发生变化时会自动调用监听方法。
  
### 18. 沙盒
iOS中沙盒机制是一种安全体系，每个iOS程序都有一个独立的文件系统（存储空间），而且只能在对应的文件系统中进行操作，此区域称为沙盒（sandbox）。默认情况下，沙盒下有三个文件夹：

* **Documents：**  
	保存应用程序重要数据文件和用户数据文件等。iTunes同步时会包括此目录。
	
* **Library：**  
	Library下有两个文件夹：
	* Caches  
	  保存缓存文件，此目录下文件不会自动删除，如果要删除时需要开发者手动删除。iTunes不会同步此目录。
	* Preferences  
	  保存应用程序的偏好设置，使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中。iTunes会同步该目录。

* **tmp：**   
  保存应用运行时需要的临时数据。应用没有运行时，系统可能会删除该目录下的文件，iPhone重启时，该目录的文件会失效。iTunes不会同步此目录
  
### 19. 多线程
iOS中实现多线程一般有四种方案：

* **pthread**  
	pthread是一套通用的多线程的API，可以在Unix / Linux / Windows 等系统跨平台使用，使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，所以我们在iOS开发中几乎不使用pthread。使用时，需要先#import \<pthread.h>,然后创建线程，并开启线程执行任务：
		
	```
	// 创建线程 —— 定义一个pthread_t类型变量
   pthread_t thread;
	// 开启线程 —— 执行任务
	pthread_create(&thread, NULL, run, NULL);
	
	// 新线程调用方法，里边为需要执行的任务
	void * run(void *param) {
    	NSLog(@"%@", [NSThread currentThread]);
    	return NULL;
    }                  
	```	
	
* **NSThread**  
  相对轻量级，简单易用，可以直接操作线程对象，但是需要自己管理线程的生命周期，线程同步、加锁等，会导致一定的性能开销。使用非常简单：
  * 先创建线程，再启动线程
  
   	 ```
    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];    
	[thread start]; 
    ```
  * 创建线程后自动启动线程
  
 	 ```
 	 [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];
 	 ```
  * 隐式创建线程并启动
  
 	 ```
  	[self performSelectorInBackground:@selector(run) withObject:nil];
 	 ```

* **GCD**  
  GCD — Grand Central Dispatch,是苹果为多核的并行运算提出的解决方案，会自动合理的利用更多的CPU核心，GCD会自动管理线程的生命周期（创建，调度任务，销毁等），完全不需要我们管理。GCD使用的是C语言，不过由于使用了block，使用起来很方便。GCD的一些用法：
  * **主队列**  
    一种特殊的串行队列，用于刷新UI，不用创建，直接获取即可。
    
   	 ```
   	 dispatch_queue_t queue = dispatch_get_main_queue();
  	 ```	
  * **全局队列**  
    系统提供的一个并行队列，同样不用创建，直接获取即可。
  	
  	 ```
  	 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
  	 ```
  * 串行队列  
    任务按照顺序执行
  
  	 ```
  	 dispatch_queue_t queue = dispatch_queue_create("serial", DISPATCH_QUEUE_SERIAL);
  	 ```
  * **并行队列**  
    可以让多个任务同时执行
    
     ```
     dispatch_queue_t queue = dispatch_queue_create("concurrent", DISPATCH_QUEUE_CONCURRENT);
     ```	 
  * **同步执行**  
    这个任务必须执行完毕，才可以执行下面的代码
    
     ```
     dispatch_sync(queue, ^{
     		// 任务执行代码
  	  });
     ```
  * **异步执行**  
    会自动开启一个线程来执行任务
    
     ```
     dispatch_async(queue, ^{
      		// 任务执行代码
   	  }); 
     ```
   * **延迟执行**  
     在一段时间后再执行这个任务
   
     ```
     dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
			// 3秒后执行这里的任务
     });
     ```  
   * **栅栏方法**   
     等待栅栏方法前面的操作执行完毕，再执行栅栏方法，才能执行栅栏方法之后的操作。需要配合GCD的并行队列一起使用。
    
     ```
     dispatch_queue_t queue = dispatch_queue_create("concurrent", DISPATCH_QUEUE_CONCURRENT);
   
     dispatch_async(queue, ^{
			// 任务1
     });
    
     dispatch_async(queue, ^{
        	// 任务2
     });
    
     dispatch_barrier_async(queue, ^{
			// 栅栏方法
     });
    
     dispatch_async(queue, ^{
			// 任务3
     });
     ```
     会先执行任务1和任务2再执行栅栏方法，最后执行任务3，任务1和任务2由于并行先后顺序不定
     
   * **一次性代码**  
     在程序运行期间只会执行一次，可以用来创建单例或者放程序运行期间只执行一次的代码。
    
     ```
     static dispatch_once_t onceToken;
     dispatch_once(&onceToken, ^{
			// 只执行一次的代码
     });
     ```
   * **快速迭代方法**  
     dispatch_apply，类似for循序，会在指定的queue中运行block任务n次，如果是并行队列，则会并发的执行block。ispatch\_apply是一个同步调用，block任务执行n次后才返回。
   
     ```
     dispatch_queue_t queue = dispatch_queue_create("concurrent", DISPATCH_QUEUE_CONCURRENT);
     dispatch_apply(5, queue, ^(size_t index) {
			NSLog(@"%ld",index);
     });
    ```
会无序输出0、1、2、3、4，如果是串行队列则会顺序输出

* **NSOperation和NSOperatonQueue**
 	* **NSOperation**  
     NSOperation是对GCD的封装，完全面向对象，所以使用起来更好理解。NSOperation和NSOperatonQueue分别对应GCD的任务和队列。NSOperation是一个抽象类，所以不能封装任务,但系统已经为我们封装了NSInvocationOperation和NSBlockOperation这两个实体类，也可以继承NSOperation来自定义自己的操作。  
     使用起来很简单，创建一个operation，然后调用start方法来启动任务，默认在当前线程执行。想要中途取消一个任务，只需要调用cancel方法。
  
 		 * **NSInvocationOperation**

    		```
    		NSInvocationOperation *operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(run) object:nil];
    		[operation start];
    		```
    
 		 * **NSBlockOperation**  
   		   NSBlockOperation可以通过addExecutionBlock来添加多个任务，多个任务是并发的执行，默认在主线程执行，如果主线程有执行的代码，则会放到子线程里。block里面的代码是同步执行。
    
     		```
     		NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
					// 任务执行代码
     		}];
    
     		[operation addExecutionBlock:^{
					// 任务执行代码
     		}];
    
     		[operation start];    
     		```
 	* **NSOperationQueue**   
     操作NSOperation的队列，分为主队列和自定义队列，NSOperationQueue里的任务将会异步执行。放入NSOperationQueue的NSOperation不用再调用start方法，系统会在空闲的时候自动开始执行队列里的任务。
   
 		 * **主队列：**  
          主队列不用创建，直接获取即可,主队列里的任务将运行在主线程上
   
    	   ```
     	   NSInvocationOperation *invoationOperation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(run) object:nil];
     	   NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];
     	   [mainQueue addOperation:invoationOperation];
   	 	   ```
 		 * **自定义队列**   
        自定义队列里的任务将运行在子线程上
     
    	   ```
    	   NSInvocationOperation *invoationOperation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(run) object:nil];
    	   NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
    	          // 任务执行代码
    	   }]; 
          
    	   NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    	   queue.maxConcurrentOperationCount = 3;
    	   [queue addOperation:invoationOperation];
    	   [queue addOperation:blockOperation];
    	   ```
		更简单的自定义队列
        
    	   ```
    	   NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    	   [queue addOperationWithBlock:^{
          	// 任务执行代码
    	   }];
    	   ```
 		 * 添加依赖关系  
          NSOperationQueue可以添加依赖关系，比如任务1依赖于任务2，那么添加依赖关系后，只有任务2执行完毕才会执行任务1。  
          添加依赖关系，注意不要循环依赖，否则会造成死锁，原因类似循环引用。  
          使用依赖建议只使用NSInvocationOperation，NSInvocationOperation和NSBlockOperation混用会导致依赖关系无法正常实现。  
          依赖关系不光在同队列中生效，不同队列的NSOperation对象之前设置的依赖关系一样会生效。
         
    	   ```
    	   NSInvocationOperation *invoationOperation1 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(run1) object:nil];
    	   NSInvocationOperation *invoationOperation2 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(run2) object:nil];

    	   NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    	   [invoationOperation2 addDependency:invoationOperation1];
    	   [queue addOperation:invoationOperation1];
    	   [queue addOperation:invoationOperation2];
    	   ```  
 		 * NSOperationQueue其他操作       
          NSOperationQueue可以通过maxConcurrentOperationCount来设置最大并发数。  
          NSOperationQueue可以暂停和取消，设置暂停只需设置suspended的即可；取消可以调用某个NSOperation的cancel方法来取消某个Operation，也可以调用NSOperationQueue的cancelAllOperations来取消所有任务。需要注意的是暂停和取消不会暂停和取消正在执行的Operation，而是不再调用新的Operation。
     